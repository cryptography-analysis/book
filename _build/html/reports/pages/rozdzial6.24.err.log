Traceback (most recent call last):
  File "/usr/local/lib/python3.10/dist-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 1204, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/usr/local/lib/python3.10/dist-packages/nbclient/util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/usr/local/lib/python3.10/dist-packages/nbclient/util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "/usr/lib/python3.10/asyncio/base_events.py", line 646, in run_until_complete
    return future.result()
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 663, in async_execute
    await self.async_execute_cell(
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
from os import *
from io import *
from numpy import *
from itertools import permutations
# Atal ma szygram o dÅ‚ugoÅ›ci klucza dziennego 8,9,10 literowego naleÅ¼y odkomentowaÄ‡ oznaczonÄ… linijke w kodzie

# Funkcja rozdzielania wierszy/kolumn na pary liter

def makePairs(permMatrix, numCols, numRows):
   # UtworzyÄ‡ pary gÃ³rnych/bocznych liter i zwrÃ³ciÄ‡ pary oddzielone kolumnami?

    pairs = ''
   #chce co drugi wiersz i parÄ™ kolumn
    evenRows = numRows if numRows % 2 == 0 else numRows - 1
    evenRows = (evenRows / 2)
   # parzysteRzÄ™dy = liczbaRzÄ™dÃ³w
    evenCols = (numCols / 2)
   # Przejrzyj co drugi wiersz, zbierajÄ…c pary liter kolumn
    for j in range(0, evenRows):
        for i in range(0, evenCols):
            pairs = pairs + permMatrix[i * 2][j * 2] + permMatrix[(i * 2) + 1][j * 2] + ' '

   # zwrÃ³Ä‡ pojedyncze litery wygenerowane przez substytut()
    return substitute(pairs);



# Funkcja przeksztaÅ‚cania par liter w pojedyncze litery
def substitute(pairs):
    # ZastÄ…p pary liter pojedynczymi literami i usuÅ„ spacje

    pairs = pairs.replace('AA', 'A')
    pairs = pairs.replace('AD', 'B')
    pairs = pairs.replace('AF', 'C')
    pairs = pairs.replace('AG', 'D')
    pairs = pairs.replace('AX', 'E')
    pairs = pairs.replace('DA', 'F')
    pairs = pairs.replace('DD', 'G')
    pairs = pairs.replace('DF', 'H')
    pairs = pairs.replace('DG', 'I')
    pairs = pairs.replace('DX', 'K')
    pairs = pairs.replace('FA', 'L')
    pairs = pairs.replace('FD', 'M')
    pairs = pairs.replace('FF', 'N')
    pairs = pairs.replace('FG', 'O')
    pairs = pairs.replace('FX', 'P')
    pairs = pairs.replace('GA', 'Q')
    pairs = pairs.replace('GD', 'R')
    pairs = pairs.replace('GF', 'S')
    pairs = pairs.replace('GG', 'T')
    pairs = pairs.replace('GX', 'U')
    pairs = pairs.replace('XA', 'V')
    pairs = pairs.replace('XD', 'W')
    pairs = pairs.replace('XF', 'X')
    pairs = pairs.replace('XG', 'Y')
    pairs = pairs.replace('XX', 'Z')
    pairs = pairs.replace(' ', '')

    return pairs;


# Funkcja do obliczania IC (Index of Coincidence)
def indexOfCoincidence(letters):
    # Oblicz wspÃ³Å‚czynnik koincydencji dla podanych liter

    # IC = suma(Ni(Ni-1))/N(N-1)
    N = len(letters)
    alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
                'V', 'W', 'X', 'Y', 'Z']
    sumFreq = 0

    # Dla kaÅ¼dej moÅ¼liwej litery alfabetu policz liczbÄ™ wystÄ…pieÅ„ w podanym ciÄ…gu
    # i obliczyÄ‡ Ni(Ni-1), gdzie Ni jest czÄ™stotliwoÅ›ciÄ… litery i w Å‚aÅ„cuchu. DodaÄ‡ wszystkie wartoÅ›ci Ni(Ni-1) dla i=1:26
    for letter in alphabet:
        freq = letters.count(letter)
        sumFreq = sumFreq + freq * (freq - 1)

    # return the numerator divided by the total number of letters N times N-1
    return sumFreq / float(N * (N - 1));


## PoniÅ¼ej funkcja main

# wprowadÅº tekst zaszyfrowany ADFGX
str = "XDXAGGXGXXGGFAXGXFDAAAAGDAXAXDFGDFFFGDXGFGAXXAADXFGGGGXXADDGXFAFDFXDGFXAGGGGADAAXXGFXDDGXDGFDDAGXDDGXXXGXDDFAFFDXFDGADAFAGADGDDAAGDGDGDGAGAGDDXGGGDGGGAGXFXAADFAADGAAXADDDFGFDFDXDXAAFDADFDGGGXGGGXGXXFGXADFAGDGAFGFADDGXGADGFADDDDDDDAFAFFADGDAAFGFXAAFADADGAFGXFAFDDAADGDFGAXGDAAFAGXXDFDGXDGAGGAADFAADGXGAGXFFXDFGAFGAGAXXFXADGAGAGXDAFFDXFFAXFADXAAGADAAFDADDFXDDGDAGGAFXXFAGFXAFGXFXFAXDDXDAGDXDDAAAGXAXGXFADDFAAXAGADFAGADDAGAGAGADFADDDADGFXDDGXXAGAXFAFDFAFAXFFAADAGAGDXDDXGXDAAADXAGFADDFXDXFGDGGADGAGDXAXDDGGAXDGDDFAXDFAFXDDAXGXGGDXFAFAADGXAADFGDAGFGGXGDGDDXDDGDDFXDGDDAAAFAAGDAAGFFXGXAADAFGGXFAFDADGDADGXGAFADDGFAFDAAAAXGADAFDDXAFAXGDDADGGXAXGFAAAFDADAGGAAGGFGXADGDAFAAGDAGAGXGADFFAAGDAGXFFGXAFDAGGFDGXDADDDDGGFAFAAGAXADGXFXAXXDGFAGGXADFFADAGFAGAGDDAXFGADFAAFFFGDGGDFAGAAAADFAAXGXXFFDGXDFFGGAFXFADGDADFDAGGGADFFAAGGXAGFDXDGAFDDADAFGFDGGFXGAAAXFADDXGGGDGXDFDDGXGDDGFFADDFGAADDXDGGDFDGGDXDFAAFXDFAAGXAAFFAADAXAGXDAXDAXAAGXDGDDGFDDDAFGDAGAFGGXFAGDFFDFAGFAGFGXGGGFDXGADXFGGDADADGFADDGAAGAFXFAGADDFGGXGXDAFXDAFDGAAXAXFGAAGXGFGGAXGDDAFGGDFFDDXFADAAGDFFFAFGDXDXFAXAADAFFDDGAXDGFGDAGXXDGGDXFDGAFXXXDXAGFXDDDAXGGADFFDAAAXGFADDDGXFFXFDAFAFGDADGFGXGDFDDAFDDDFGAXGDAGGXGXGFAAGXGXFXAAFDAGGXFDFGAGGGFFAFFDGFAAGXDDGFFAADGXAXDAFDDFDDGXFDDAGXDXDAFXDFADFDDAAGGFDAFXGAGADXGDGGAFXAGADDGFFXDADXFAADGFDAFADDFGDFFAFDGDGXFDADXGFAGDDDXDGAAAFDAGAADAGXGDDAFFAAGXDDDGGGGDDDFAGGGXXXGXFDAADFDAADAGGGFGFXXXGDGGFGGDFXDAGAFGGXGAFGGFFDXFXGAGAGXAFFAFAAXGFGXAADAFDGAGDGDDAGXDXGGADAADAGXDGGFFDGGGFDXADGAADAXGFFGXFFDDGDFDFFAGXGFDDFGGXADDDDXDGAGADFDAGFFAADXAADADDDDGGFGFXDDFDAFDAFDFGAXFXGDXDXADDGXFXFDAGGAGDDDGDDDAXADAGDXGXGXFDXFGDGXGAGGFDGDAAGGAXGAGXGAFFGADDADDXXFDDGAAGGDFAFDFADGAAFAXXFGGAXDFGFDAAGDDAXDDGFFXDFGGDGAGXGXGFAXAXXAAXADAFGGGGAAXAGGADGAGGADAFDXGDFGDGDFGFGGGGAGDXADXGFDXXDDDAFDAGDAXXDAADAFAAADDGGGDGFAADAGXXGDXGADAFXDFDGGXAFGAGAGAGAGXAXFADFDXDFFAGDGXGXDADXGXXFFDDDAXDXGDGXFDGFAFDDGAFDGXFXFGAAGAFXXXGXFDAXFFFXGAFGDFGGDXADGAGXGXXGFXADGDADFGGXFDFXGGGDGDGDFDDXAFGXXXGDDFGGDFAAAXGDGXGAGXFGDAGFGFXDAAFDDGFFXDGXDFFDGXFFADGGFFXDXDGGGXGDADXAGGDFFGADXGADAFGAGFAGGGGDGDAAXFFGADGFAAAFXGXFAGGAADGGXDAFDFXDDGXGFAXFXFADXGXFXGDGDGAAAAFAGDGGFDAGGGDDFGXFAFDAXAAXXGDDAADFAGXDGFDDXDGGDGAFAFAXXADFXADGXGXFXXAAGDXFDADFGADAADGGAFGGGDXDXAAFDGAADAAAXGDADDDADGAGDFXFDFAADAGFXAADDGDFFFDDFFAGFFXGAXFDDAGAAFGDAGGGADDGDFFDDDAADAGGAAAADDAFGGDFXXXDXFGAAGXGAADDAFXGAGDDAAGGFGGXFDAAAGXDAFAFAGDGFFAADGDFDXDAAGGDAAAAAGGADXDGDGXXFGDGAFXAAGADXFXXDFDFAXAFXGAAGFFFFFDGXFAAXAGAXADADAXDDADGADDDDGGDAGFAXAXFGGAGXXGADGXAAGAGXDXFADGGAFDGAGDGXXGXDGXAXDADDDGDXAAXFGAFDFFXXGDDDGDXAFAGDGDFXGAGAGDDXXF"


# Ustaw numCols na Å¼Ä…danÄ… dÅ‚ugoÅ›Ä‡ klucza
# liczba kolumn = dÅ‚ugoÅ›Ä‡ klucza
numCols = 9

numLetters = len(str)  # caÅ‚kowita liczba liter w tekÅ›cie zaszyfrowanym
numRows = numLetters / numCols # liczba wierszy w kaÅ¼dej kolumnie

# UtwÃ³rz listy przechowywania danych !upewnij siÄ™, Å¼e masz litery numCols w inicjalizacji transpoMatrix
transpoMatrix = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
for i in range(numCols):
    transpoMatrix[i] = str[i * numRows: (i + 1) * numRows]

# uzyskaÄ‡ wszystkie moÅ¼liwe uporzÄ…dkowania permutacji
permOrders = list(permutations(range(0, numCols)))

# dla kaÅ¼dej permutacji wierszy oblicz IC dla par liter jako pojedynczych liter
# Uwaga: ta wersja makePairs() wykorzystuje tylko poÅ‚owÄ™ wierszy i potencjalnie nie wszystkie kolumny
candidateOrders = {}
for order in permOrders:
    # Posortuj macierz wedÅ‚ug kolejnoÅ›ci permutacji
    permMatrix = [x for (y, x) in sorted(zip(order, transpoMatrix), key=lambda pair: pair[0])]
    # TwÃ³rz pary liter w zaleÅ¼noÅ›ci od tego, czy dÅ‚ugoÅ›Ä‡ klucza jest parzysta czy nieparzysta
    ## jeÅ›li dÅ‚ugoÅ›Ä‡ klucza jest parzysta, to kaÅ¼da litera w kolumnie bÄ™dzie tego samego â€žrodzajuâ€ (gÃ³ra lub bok)
    ## abyÅ›my mogli uÅ¼yÄ‡ kaÅ¼dej kolumny w kolejnoÅ›ci transpozycji
    if numCols % 2 == 0:
        letters = makePairs(permMatrix, numCols, numRows)
    ## jeÅ›li dÅ‚ugoÅ›Ä‡ klucza jest nieparzysta, to kaÅ¼da inna litera w kolumnie bÄ™dzie takiego samaego 'rodzaju'
    ## wiÄ™c musimy uÅ¼yÄ‡ wszystkich kolumn z wyjÄ…tkiem ostatniej
    else:
        letters = makePairs(permMatrix[0:(numCols - 1)], numCols - 1, numRows)
    # Oblicz indeks zbieÅ¼noÅ›ci dla pojedynczych liter
    index = indexOfCoincidence(letters)
    # Zapisz kolejnoÅ›Ä‡ permutacji i IC jako element dict
    candidateOrders[order] = index

# wydrukuj 100 najlepszych kandydatÃ³w przez IC (wiÄ™ksze jest bardziej angielskie w znaczeniu ma wiÄ™kszy wspÃ³Å‚czynik wystÄ…pienia w j.angielskim
# print(sortowane(candidateOrders. items(), key=lambda x:-x[1])[:100])
# Zapisz tylko kandydatÃ³w, ktÃ³rzy sÄ… najbardziej podobni do angielskiego (co jest okoÅ‚o 0. 063) wspÃ³Å‚czynik wystÄ…pienia na danej pozycji

topCandidates = {}
for k, v in candidateOrders.items():
    if v > 0.06:
        topCandidates[k] = v

# usuwamy duÅ¼e zmienne, aby program byÅ‚ mniej uciÄ…Å¼liwy zbÄ™dne proponowania na dane pozycjie
del candidateOrders
del permOrders

# wydrukuj caÅ‚kowitÄ… liczbÄ™ kandydatÃ³w w jÄ™zyku angielskim
numCandidates = len(topCandidates)
print(numCandidates)

# oblicz czÄ™stotliwoÅ›Ä‡ kaÅ¼dego numeru kolumny na kaÅ¼dej pozycji w najlepszych zamÃ³wieniach kandydujÄ…cych liter na pozycji
# odkomentujemy odpowiedniÄ… linijkÄ™ w zaleÅ¼noÅ›ci od dÅ‚ugoÅ›ci klucza dziennego 8,9,10 dÅ‚ugoÅ›ci klucza dziennego
# candFreq = [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]
candFreq = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]
# candFreq = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

for k in topCandidates.keys():  # dla kaÅ¼dego najlepszego kandydata,
    for j in range(numCols): # dla kaÅ¼dej pozycji w transpozycji
        for i in range(numCols): # dla kaÅ¼dej moÅ¼liwej kolumny
            candFreq[i][j] += 1 if k[j] == i else 0

print(candFreq)
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mTypeError[0m                                 Traceback (most recent call last)
Cell [0;32mIn[1], line 98[0m
[1;32m     96[0m transpoMatrix [38;5;241m=[39m [[38;5;124m'[39m[38;5;124ma[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mb[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mc[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124md[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124me[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mf[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mg[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mh[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mi[39m[38;5;124m'[39m]
[1;32m     97[0m [38;5;28;01mfor[39;00m i [38;5;129;01min[39;00m [38;5;28mrange[39m(numCols):
[0;32m---> 98[0m     transpoMatrix[i] [38;5;241m=[39m [38;5;28;43mstr[39;49m[43m[[49m[43mi[49m[43m [49m[38;5;241;43m*[39;49m[43m [49m[43mnumRows[49m[43m:[49m[43m [49m[43m([49m[43mi[49m[43m [49m[38;5;241;43m+[39;49m[43m [49m[38;5;241;43m1[39;49m[43m)[49m[43m [49m[38;5;241;43m*[39;49m[43m [49m[43mnumRows[49m[43m][49m
[1;32m    100[0m [38;5;66;03m# uzyskaÄ‡ wszystkie moÅ¼liwe uporzÄ…dkowania permutacji[39;00m
[1;32m    101[0m permOrders [38;5;241m=[39m [38;5;28mlist[39m(permutations([38;5;28mrange[39m([38;5;241m0[39m, numCols)))

[0;31mTypeError[0m: slice indices must be integers or None or have an __index__ method
TypeError: slice indices must be integers or None or have an __index__ method

